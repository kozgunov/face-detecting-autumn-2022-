import cv2
import time

debug = False

def face_capture(camera, sign_exit):
    prev_time = time.perf_counter()

    # eye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml')
    # smile_cascade = cv2.CascadeClassifier('haarcascade_smile.xml')

    face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
    left_eye_cascade = cv2.CascadeClassifier('haarcascade_lefteye_2splits.xml')
    right_eye_cascade = cv2.CascadeClassifier('haarcascade_righteye_2splits.xml')


    img_counter = 0

    x = int()
    y = int()
    w = int()
    h = int()
    lex = int()
    ley = int()
    lew = int()
    leh = int()
    rex = int()
    rey = int()
    rew = int()
    reh = int()
    center_ellipse_x = int()
    center_ellipse_y = int()
    axes_x = int()
    axes_y = int()

    while sign_exit:
        ret, frame = camera.read()
        gray = cv2.cvtColor(frame, cv2.IMREAD_COLOR)  # or cv2.COLOR_BGR2GRAY as option
        if not ret:
            print("failed to grab frame")
            break

        restriction_of_right_eye_gray_color = None
        restriction_of_left_eye_gray_color = None

        current_time = time.perf_counter()
        if current_time - prev_time >= 0.01:
            prev_time = current_time

            faces = face_cascade.detectMultiScale(gray, scaleFactor=1.03, minNeighbors=3, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE)

            for (x, y, w, h) in faces:
                center_ellipse_x = round(x + w / 2)
                center_ellipse_y = round(y + h / 2)
                axes_x = round((abs(w)) / 1.35)
                axes_y = round(abs(h) / 1.85)

                restriction_of_left_eye_gray = gray[y: y + round(1 / 2 * h), x + round(1 / 2 * w): x + w]
                restriction_of_left_eye_gray_color = frame[y: y + round(1 / 2 * h), x + round(1 / 2 * w): x + w]
                restriction_of_right_eye_gray = gray[y: y + round(1 / 2 * h), x: x + round(1 / 2 * w)]
                restriction_of_right_eye_gray_color = frame[y: y + round(1 / 2 * h), x: x + round(1 / 2 * w)]

                left_eye = left_eye_cascade.detectMultiScale(restriction_of_left_eye_gray, scaleFactor=1.05, minNeighbors=3, minSize=(2, 2), flags=cv2.CASCADE_SCALE_IMAGE)
                right_eye = right_eye_cascade.detectMultiScale(restriction_of_right_eye_gray, scaleFactor=1.05, minNeighbors=3, minSize=(2, 2), flags=cv2.CASCADE_SCALE_IMAGE)

                for (rex, rey, reh, rew) in right_eye:
                    pass
                for (lex, ley, leh, lew) in left_eye:
                    pass

        cv2.ellipse(frame, (center_ellipse_x, center_ellipse_y), (axes_x, axes_y), 90, 0, 360, (0, 255, 0), thickness=4)  # face
        cv2.circle(restriction_of_left_eye_gray_color, (lex + round(lew / 2), ley + round(leh / 2)), 15, (2, 244, 255), thickness=2, lineType=0, shift=0)  # eyes
        cv2.circle(restriction_of_right_eye_gray_color, (rex + round(rew / 2), rey + round(reh / 2)), 20, (200, 2, 2), thickness=2, lineType=0, shift=0)  # eyes
        cv2.imshow('computer camera online', frame)

        k = cv2.waitKey(1)
        if k != -1:
            img_counter += 1
            keyboard_input(frame, sign_exit, img_counter, k)
    camera.release()
    cv2.DestroyALLWIndows()


def keyboard_input(frame, sign_exit, img_counter, k):  # taking photo & exit
    print(k)
    if k == 13:  # ENTER pressed
        print("Escape hit, closing...")
        sign_exit = False
        exit()
    elif k == 32:  # SPACE pressed
        img_name = "opencv_frame_{}.png".format(img_counter)
        cv2.imwrite(img_name, frame)
        print("{} written!".format(img_name))

    return sign_exit, k


def eye_detecting(ex, ey, eh, ew):
    return ex, ey, eh, ew


def main():
    sign_exit = True

    camera = cv2.VideoCapture(0)  # computer camera
    # camera = cv2.VideoCapture("Koijot.mp4 ")  # downloaded video
    cv2.namedWindow("computer camera online")

    while sign_exit:
        face_capture(camera, sign_exit)


main()
